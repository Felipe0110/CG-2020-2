 <!DOCTYPE html>
<html>
  <head>
    <title>Humanoide</title>
      <style>
            html, body { margin: 0; padding: 0; overflow: hidden; }
            #info {
                position: absolute;
                padding: 10px;
                width: 100%;
                text-align: center;
                color: #FFFFFF;
            }
        </style>
  </head>
  <body>
   <div id="info">HUMANOIDE<br/>
        </div>
    <script src="js/three.min.js"></script>
    <script src='js/libs/dat.gui.min.js'></script>
    <script>
		var scene, aspect, camera, renderer,controls;
		var startTime = Date.now();
		/*var angleX = 0;
        var angleY = 0;
       	var angleZ = 0;*/
		//var c,s,tx=0,ty=0,tz=0;
        var Cabeza,Torso, BrazoIzq,BrazoDer,HombroIzq,HombroDer,GluteoIzq,GluteoDer,PiernaIzq,PiernaDer,RodillaIzq,RodillaDer,CanillaIzq,CanillaDer,CodoIzq,CodoDer,AnteIzq,AnteDer, Cadera;
        var roty;
		// Creacion de funciones 
        
		init();
		animate();
	
		function init(){
            
            //Creacion de estructura basica de Three.js
            scene = new THREE.Scene();
			aspect = window.innerWidth / window.innerHeight;
			camera = new THREE.PerspectiveCamera( 45, aspect, 0.1, 1000);
            renderer = new THREE.WebGLRenderer();
			renderer.setSize( window.innerWidth, window.innerHeight );
			document.body.appendChild( renderer.domElement );
			
			var x = new THREE.Vector3( 1, 0, 0 );
			var y = new THREE.Vector3( 0, 1, 0 );
		  	var z = new THREE.Vector3( 0, 0, 1 );
			var origin = new THREE.Vector3( 0, 0, 0 );

            var ejeX = new THREE.ArrowHelper( x, origin, 1, 0xFF1400 );
            var ejeY = new THREE.ArrowHelper( y, origin, 1, 0x7DFF00 );
            var ejeZ = new THREE.ArrowHelper( z, origin, 1, 0x0027FF );
			
			var onKeyDown = function ( event ) {
				switch ( event.keyCode ) {
					case 38:
						roty = true;
						break;
							
				}
			};	  
		  			
			var onKeyUp = function ( event ) {
				roty = false;
				
			};
			
			document.addEventListener( 'keydown', onKeyDown, false );
			document.addEventListener( 'keyup', onKeyUp, false );
			
            
            
            //Creacion de cabeza
            var geoEsfera= new THREE.Geometry();
            var resEsfera = 100; 
            for( var i = 0; i < resEsfera; i+=0.5){
                for( var j = 0; j < resEsfera; j+=0.5){
                    var punto = new THREE.Vector3();
                    punto.x = 1 * Math.cos( ( j * 2 * Math.PI )/resEsfera) * Math.sin( ( i * Math.PI )/resEsfera) ;
                    punto.y = 1 * Math.sin( ( j * 2 * Math.PI )/resEsfera) * Math.sin( ( i * Math.PI )/resEsfera) ;
                    punto.z = 1 * Math.cos( ( i * Math.PI )/resEsfera) ;
                    geoEsfera.vertices.push( punto );
                }
            }
            var matEsfera = new THREE.PointsMaterial( { color: 0x6E6E6E, size: 0.1 } );
			Cabeza = new THREE.Points( geoEsfera, matEsfera);
            Cabeza.applyMatrix( new THREE.Matrix4().makeTranslation(1,5.2,1.5) );        
            
			
            //Torso
			var geoTorso= new THREE.Geometry();
            var resTorso = 2; // controla el numero de lineas que se crean
            //Se posicionan los puntos en P(x,y,z)
            for( var i = 0; i < 3; i+=0.06){
                for( var j = 0; j < 4; j+=0.06){
					for(var k=0;k<2;k+=0.06){
                    var punto = new THREE.Vector3();
                     punto.x =   k;
                     punto.y =   j;
                     punto.z =   i;
                     geoTorso.vertices.push( punto );
					}
                }
            }
            var matTorso= new THREE.PointsMaterial( { color: 0x60000FF, size: 0.1 } );
			Torso = new THREE.Points( geoTorso, matTorso);
            Torso.applyMatrix( new THREE.Matrix4().makeTranslation(0.5,1,0));
			
			
			//Cadera
			var geoCadera= new THREE.Geometry();
            var resCadera = 2; // controla el numero de lineas que se crean
            //Se posicionan los puntos en P(x,y,z)
            for( var i = 0; i < 3; i+=0.06){
                for( var j = 0; j < 1; j+=0.06){
					for(var k=0;k<3;k+=0.06){
                    var punto = new THREE.Vector3();
                     punto.x =   k;
                     punto.y =   j;
                     punto.z =   i;
                     geoCadera.vertices.push( punto );
					}
                }
            }
            var matCadera= new THREE.PointsMaterial( { color: 0x00FBFF, size: 0.1 } );
			Cadera = new THREE.Points( geoCadera, matCadera);
			//Cadera.applyMatrix( new THREE.Matrix4().makeTranslation(0,0,0) );					 
			//Hombros
			var geoHombro= new THREE.Geometry();
            var resHombro = 100; 
            for( var i = 0; i < resHombro; i+=0.5){
                for( var j = 0; j < resHombro; j+=0.5){
                    var punto = new THREE.Vector3();
                    punto.x = 0.5 * Math.cos( ( j * 2 * Math.PI )/resHombro) * Math.sin( ( i * Math.PI )/resHombro) ;
                    punto.y = 0.5 * Math.sin( ( j * 2 * Math.PI )/resHombro) * Math.sin( ( i * Math.PI )/resHombro) ;
                    punto.z = 0.5 * Math.cos( ( i * Math.PI )/resHombro) ;
                    geoHombro.vertices.push( punto );
                }
            }
            var matHombro = new THREE.PointsMaterial( { color: 0x8E00FF, size: 0.1 } );
			
			HombroIzq = new THREE.Points( geoHombro, matHombro);
			HombroIzq.applyMatrix( new THREE.Matrix4().makeTranslation(1,4,-0.5) );
			HombroDer = new THREE.Points( geoHombro, matHombro);
			HombroDer.applyMatrix( new THREE.Matrix4().makeTranslation(1,4,3.5) );
			
			RodillaIzq = new THREE.Points( geoHombro, matHombro);
			RodillaIzq.applyMatrix( new THREE.Matrix4().makeTranslation(0,0,0) );
			
			RodillaDer = new THREE.Points( geoHombro, matHombro);
			RodillaDer.applyMatrix( new THREE.Matrix4().makeTranslation(0,0,0) );
			
			
			var geoCodo= new THREE.Geometry();
            var resCodo = 100; 
            for( var i = 0; i < resCodo; i+=0.5){
                for( var j = 0; j < resCodo; j+=0.5){
                    var punto = new THREE.Vector3();
                    punto.x = 0.3* Math.cos( ( j * 2 * Math.PI )/resCodo) * Math.sin( ( i * Math.PI )/resCodo) ;
                    punto.y = 0.3* Math.sin( ( j * 2 * Math.PI )/resCodo) * Math.sin( ( i * Math.PI )/resCodo) ;
                    punto.z = 0.3* Math.cos( ( i * Math.PI )/resCodo) ;
                    geoCodo.vertices.push( punto );
                }
            }
            var matCodo = new THREE.PointsMaterial( { color: 0xFFF800, size: 0.1 } );
			
			CodoIzq = new THREE.Points( geoCodo, matCodo);
			CodoIzq.applyMatrix( new THREE.Matrix4().makeTranslation(0,0,0) );
			CodoDer = new THREE.Points( geoCodo, matCodo);
			CodoDer.applyMatrix( new THREE.Matrix4().makeTranslation(0,0,0 ))
			
			
			
			var geoGluteo= new THREE.Geometry();
            var resGluteo = 100; 
            for( var i = 0; i < resGluteo; i+=0.5){
                for( var j = 0; j < resGluteo; j+=0.5){
                    var punto = new THREE.Vector3();
                    punto.x = 0.6 * Math.cos( ( j * 2 * Math.PI )/resGluteo) * Math.sin( ( i * Math.PI )/resGluteo) ;
                    punto.y = 0.6 * Math.sin( ( j * 2 * Math.PI )/resGluteo) * Math.sin( ( i * Math.PI )/resGluteo) ;
                    punto.z = 0.6 * Math.cos( ( i * Math.PI )/resGluteo) ;
                    geoGluteo.vertices.push( punto );
                }
            }
            var matGluteo = new THREE.PointsMaterial( { color: 0x00FF07, size: 0.1 } );
			
			
			GluteoIzq = new THREE.Points( geoGluteo, matGluteo);
			GluteoIzq.applyMatrix( new THREE.Matrix4().makeTranslation(1.5,-0.5,2.25) );
			GluteoDer = new THREE.Points( geoGluteo, matGluteo);
			GluteoDer.applyMatrix( new THREE.Matrix4().makeTranslation(1.5,-0.5,0.75) );
			
			
			
            //Extremidades
			 //Brazos
            var geoBrazos = new THREE.Geometry();
            var resBrazos  =50;
              for( var i = 0; i < resBrazos ; i++){
                for( var j = 0; j < resBrazos ; j++){
                    var punto = new THREE.Vector3();
                    punto.x = 0.2 * Math.cos( ( j * 2 * Math.PI )/resBrazos ) ;
                    punto.y = i/25;
                    punto.z = 0.2 * Math.sin( ( j * 2* Math.PI )/resBrazos);
                    geoBrazos .vertices.push( punto );
                }
            }
            var matBrazos  = new THREE.PointsMaterial({ color: 0xFF0064, size: 0.1 });
            BrazoIzq  = new THREE.Points (geoBrazos ,matBrazos );
            BrazoIzq.applyMatrix( new THREE.Matrix4().makeTranslation(0,-2,0) );
           	BrazoDer =  new THREE.Points (geoBrazos ,matBrazos );
			BrazoDer.applyMatrix( new THREE.Matrix4().makeTranslation(0,-2,0) );
			
			AnteIzq  = new THREE.Points (geoBrazos ,matBrazos );
            AnteIzq.applyMatrix( new THREE.Matrix4().makeTranslation(0,-2,0) );
           	AnteDer =  new THREE.Points (geoBrazos ,matBrazos );
			AnteDer.applyMatrix( new THREE.Matrix4().makeTranslation(0,-2,0) );
			
			//Piernas
			
			var geoPiernas = new THREE.Geometry();
            var resPiernas  =50;
              for( var i = 0; i < resPiernas ; i++){
                for( var j = 0; j < resPiernas ; j++){
                    var punto = new THREE.Vector3();
                    punto.x = 0.35 * Math.cos( ( j * 2 * Math.PI )/resPiernas ) ;
                    punto.y = i/15;
                    punto.z = 0.35 * Math.sin( ( j * 2* Math.PI )/resPiernas);
                    geoPiernas .vertices.push( punto );
                }
            }
       		var matPiernas  = new THREE.PointsMaterial({ color: 0xFF0064, size: 0.1 });	
			PiernaIzq = new THREE.Points (geoPiernas ,matPiernas);
			PiernaIzq.applyMatrix( new THREE.Matrix4().makeTranslation(0,-3,0) );
			PiernaDer = new THREE.Points (geoPiernas,matPiernas );
			PiernaDer.applyMatrix( new THREE.Matrix4().makeTranslation(0,-3,0) );
		
			var geoCanilla = new THREE.Geometry();
            var resCanilla  =50;
              for( var i = 0; i < resCanilla ; i++){
                for( var j = 0; j < resCanilla ; j++){
                    var punto = new THREE.Vector3();
                    punto.x = 0.3 * Math.cos( ( j * 2 * Math.PI )/resCanilla ) ;
                    punto.y = i/15;
                    punto.z = 0.3 * Math.sin( ( j * 2* Math.PI )/resCanilla);
                    geoCanilla .vertices.push( punto );
                }
            }
       		var matCanilla = new THREE.PointsMaterial({ color: 0xFF0064, size: 0.1 });	
			
			CanillaIzq = new THREE.Points (geoCanilla ,matCanilla);
			CanillaIzq.applyMatrix( new THREE.Matrix4().makeTranslation(0,-2,0) );
			CanillaDer = new THREE.Points (geoCanilla,matCanilla );
			CanillaDer.applyMatrix( new THREE.Matrix4().makeTranslation(0,-2,0) );
			elex= new THREE.Points (geoCanilla ,matCanilla);
			
			
			//Jerarquias
			Cadera.add(Torso);
			Torso.add(elex);
			Torso.add(Cabeza);
			Torso.add(HombroIzq);
			Torso.add(HombroDer);
			HombroIzq.add(BrazoIzq);
			HombroDer.add(BrazoDer);
			BrazoIzq.add(CodoIzq);
			BrazoDer.add(CodoDer);
			CodoIzq.add(AnteIzq);
			CodoDer.add(AnteDer);
			Cadera.add(GluteoIzq);
			Cadera.add(GluteoDer);
			GluteoIzq.add(PiernaIzq);
			GluteoDer.add(PiernaDer);
			PiernaIzq.add(RodillaIzq);
			PiernaDer.add(RodillaDer);
			RodillaIzq.add(CanillaIzq);
			RodillaDer.add(CanillaDer);
			
			/*pivotPoint = new THREE.Object3D();
			pivotPoint.position.set(1,1,1);
			scene.add( pivotPoint );
			
			pivotPoint.add(Cadera);
			Cadera.position.set(1,-1,1);*/
			
            scene.add(Cadera);
			scene.add(ejeX);
			scene.add(ejeY);
			scene.add(ejeZ);
			camera.position.x = 0;
			camera.position.y =	17;	 
		  	camera.position.z = 0;
			
			 /*var rotationAngles = {
                    theta1: 0,
                   
                };

                var rotation = function () {
                    angleY = THREE.Math.degToRad(rotationAngles.theta1);
                    
                    render();
                };

                var gui = new dat.GUI();
                gui.add(rotationAngles, "theta1", -90, 90, 1).onChange(rotation);
                
                rotation();*/
            
            
		  	camera.lookAt( origin );
		}
    
    function animate() {
        render();
        requestAnimationFrame( animate );
        
    }
    
    function render(){
	
		
		var c = Math.cos(0.01);
		var s = Math.sin(0.01);
		var tx = 0;
		var ty = 0;
		var tz = 0;
		
		
		var rotar = new THREE.Matrix4();
		rotar.set(c,0,s,tx*(1-c)-s*tz,
				  0,1,0,0,
				  -s,0,c,s*tx-c*tz,
				  0,0,0,1);
		Cadera.applyMatrix(rotar);							
		Cadera.elementsNeedUpdate = true;	
		

		
		

		
		
		/*var t = new THREE.Matrix4();
		t.set( 	1, 0, 0, tx,
				0, 1, 0, ty, 
				0, 0, 1, tz,
				0, 0, 0, 1	);
		var r = new THREE.Matrix4();
		r.set( 	   c,  0, s, 0,
					0,  1,  0, 0, 
				  -s,  0, c, 0,
					0,  0,  0, 1);	
		var tempMatrix = new THREE.Matrix4();
		
		var tempMatrix = new THREE.Matrix4();
		tempMatrix.copyPosition( Torso.matrix );
		Torso.applyMatrix( new THREE.Matrix4().getInverse(tempMatrix) );
		Torso.applyMatrix(rotar);
		Torso.applyMatrix( tempMatrix );
		*/
		
		//var eulerRot = new THREE.Euler(angleX, angleY, angleZ, 'ZYX');

        //Torso.setRotationFromEuler(eulerRot);
        
        camera.lookAt( 0, 0, 0 );
        
        renderer.render( scene, camera );
    }
		
	
    </script>
  </body>
</html>